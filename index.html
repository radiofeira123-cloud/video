<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gerador de Vídeo Mosaico — Arraste suas fotos</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;color-scheme: dark}
    *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071025 0%, #0f1724 60%);color:#e6eef6;display:flex;align-items:flex-start;gap:24px;padding:28px}
    .wrap{max-width:1100px;width:100%;margin:0 auto}
    header{display:flex;align-items:center;gap:18px}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 0;color:var(--muted)}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:20px;margin-top:18px}
    .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .uploader{border:2px dashed rgba(255,255,255,0.04);padding:16px;border-radius:10px;text-align:center}
    input[type=file]{display:none}
    .btn{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;padding:10px 14px;border-radius:10px;color:#021124;cursor:pointer;font-weight:600}
    .small{font-size:13px;color:var(--muted)}
    .thumbs{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;height:220px;overflow:auto;padding:6px}
    .thumb{width:72px;height:72px;border-radius:6px;object-fit:cover;box-shadow:0 2px 6px rgba(0,0,0,0.6)}
    label.switch{display:inline-flex;align-items:center;gap:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .range{width:100%}
    canvas{background:#000;border-radius:8px;display:block;max-width:100%}
    .log{font-family:monospace;font-size:13px;color:var(--muted);height:120px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
    footer{margin-top:18px;color:var(--muted);font-size:13px}
    @media(max-width:900px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Gerador de Vídeo Mosaico (MP4)</h1>
        <p class="lead">Faça upload das suas fotos (até centenas). O app monta um efeito de "abrir e multiplicar" e gera um vídeo. Recomendo Chrome/Edge.</p>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="uploader">
          <p class="small">Arraste e solte suas imagens aqui ou</p>
          <label class="btn" for="files">Selecionar fotos</label>
          <input id="files" type="file" accept="image/*" multiple>
          <div class="small" style="margin-top:8px">Suporte: JPG, PNG, WebP. Recomendado: não usar arquivos enormes (>6MB cada) para performance.</div>
          <div class="thumbs" id="thumbs"></div>

          <div class="controls">
            <div style="flex:1">
              <label class="small">Duração total (segundos)</label>
              <input id="duration" type="number" min="3" value="20" class="range">
            </div>
            <div style="width:140px">
              <label class="small">FPS</label>
              <input id="fps" type="number" min="10" max="60" value="30" style="width:100%">
            </div>
            <div style="width:140px">
              <label class="small">Largura do vídeo (px)</label>
              <input id="width" type="number" min="480" max="3840" value="1280" style="width:100%">
            </div>
          </div>

          <div style="display:flex;gap:8px;margin-top:12px;align-items:center;justify-content:center">
            <button id="generate" class="btn">Gerar Vídeo (WebM → MP4)</button>
            <button id="downloadWebm" class="btn" style="background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.06)">Baixar WebM</button>
          </div>

          <div style="margin-top:10px;text-align:left">
            <div class="small">Progresso:</div>
            <div id="log" class="log"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <div>
            <div class="small">Preview (canvas)</div>
            <div class="small" id="infoCount">0 fotos carregadas</div>
          </div>
          <div class="small">Tamanho estimado: <span id="estSize">-</span></div>
        </div>

        <div style="margin-top:12px">
          <canvas id="canvas" width="1280" height="720"></canvas>
        </div>

        <footer>
          <div class="small">Observações: gerar MP4 no navegador usa <code>ffmpeg.wasm</code> e pode demorar. Se estiver lento, baixe o WebM e use um conversor local.</div>
        </footer>
      </div>
    </div>
  </div>

  <!-- scripts -->
  <script>
    // UI elements
    const filesInput = document.getElementById('files');
    const thumbs = document.getElementById('thumbs');
    const durationInput = document.getElementById('duration');
    const fpsInput = document.getElementById('fps');
    const widthInput = document.getElementById('width');
    const canvas = document.getElementById('canvas');
    const logEl = document.getElementById('log');
    const infoCount = document.getElementById('infoCount');
    const estSize = document.getElementById('estSize');
    const generateBtn = document.getElementById('generate');
    const downloadWebmBtn = document.getElementById('downloadWebm');

    let images = [];
    let recordedBlobs = null;
    let recordedWebmBlob = null;

    function log(msg){
      logEl.textContent += msg + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog(){ logEl.textContent = ''; }

    filesInput.addEventListener('change', async (ev)=>{
      loadFiles(Array.from(ev.target.files));
    });

    // drag-n-drop
    document.addEventListener('dragover', e=>{ e.preventDefault(); });
    document.addEventListener('drop', e=>{ e.preventDefault(); const dt = e.dataTransfer; if(dt && dt.files) loadFiles(Array.from(dt.files)); });

    async function loadFiles(fileList){
      clearLog();
      log('Carregando ' + fileList.length + ' arquivos...');
      const accepted = fileList.filter(f=>f.type.startsWith('image/'));
      images = [];
      thumbs.innerHTML = '';
      for(const f of accepted){
        const url = URL.createObjectURL(f);
        const img = await loadImage(url);
        images.push(img);
        const imgEl = document.createElement('img'); imgEl.src = url; imgEl.className = 'thumb'; thumbs.appendChild(imgEl);
      }
      infoCount.textContent = images.length + ' fotos carregadas';
      estSize.textContent = Math.round( (images.length * 0.2) ) + ' MB (estimativa)';
      log('Todas as imagens carregadas na memória (apenas referências).');
    }

    function loadImage(src){
      return new Promise((res, rej)=>{
        const img = new Image(); img.onload = ()=>res(img); img.onerror = rej; img.src = src; img.crossOrigin = 'anonymous';
      });
    }

    // Core: montar animação e gravar canvas
    generateBtn.addEventListener('click', async ()=>{
      if(images.length === 0){ alert('Carregue pelo menos 1 imagem'); return; }
      generateBtn.disabled = true; downloadWebmBtn.disabled = true; clearLog();
      const duration = Number(durationInput.value) || 20; const fps = Number(fpsInput.value)||30; const width = Number(widthInput.value)||1280;
      const height = Math.round(width * 9 / 16);
      canvas.width = width; canvas.height = height;
      log(`Iniciando geração — ${images.length} imagens, ${duration}s, ${fps}fps, ${width}x${height}`);
      const stream = canvas.captureStream(fps);
      const mime = 'video/webm;codecs=vp9';
      const rec = new MediaRecorder(stream, {mimeType: mime});
      const chunks = [];
      rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      rec.start(1000/10); // solicite dados a cada 100ms

      await playAnimationOnCanvas({canvas, images, duration, fps});

      rec.stop();
      await new Promise(r=>rec.onstop = r);
      recordedBlobs = chunks;
      recordedWebmBlob = new Blob(chunks, {type: 'video/webm'});
      log('Gravação WebM concluída — tamanho: ' + Math.round(recordedWebmBlob.size/1024/1024) + ' MB');
      downloadWebmBtn.disabled = false;

      // agora converter para MP4 usando ffmpeg.wasm
      log('Carregando ffmpeg.wasm (pode demorar)...');
      try{
        await convertToMP4(recordedWebmBlob);
      }catch(err){
        log('Conversão para MP4 falhou: ' + err.message + '. Você pode baixar o WebM diretamente.');
      }

      generateBtn.disabled = false;
    });

    downloadWebmBtn.addEventListener('click', ()=>{
      if(!recordedWebmBlob){ alert('Nenhum WebM gerado ainda.'); return; }
      const a = document.createElement('a'); a.href = URL.createObjectURL(recordedWebmBlob); a.download = 'mosaico.webm'; a.click();
    });

    // Animation routine: images multiply into grid
    async function playAnimationOnCanvas({canvas, images, duration, fps}){
      const ctx = canvas.getContext('2d');
      const totalFrames = Math.max(1, Math.floor(duration * fps));
      const W = canvas.width; const H = canvas.height;
      // We'll progressively add images; final grid size is calculated from count
      const n = images.length;
      const cols = Math.ceil(Math.sqrt(n));
      const rows = Math.ceil(n / cols);
      const padding = Math.round(Math.min(W, H) * 0.006);
      const cellW = Math.floor((W - padding*(cols+1)) / cols);
      const cellH = Math.floor((H - padding*(rows+1)) / rows);

      // schedule when each image appears: spread over first 60% of duration
      const appearFrames = Math.floor(totalFrames * 0.6);
      const perImageFrame = Math.max(1, Math.floor(appearFrames / n));
      let frames = [];
      for(let f=0; f<totalFrames; f++){
        frames.push(f);
      }

      // precompute target positions
      const targets = images.map((img,i)=>{
        const r = Math.floor(i/cols); const c = i%cols;
        const x = padding + c*(cellW+padding);
        const y = padding + r*(cellH+padding);
        return {x,y,w:cellW,h:cellH};
      });

      // draw frame by frame
      for(let frame=0; frame<totalFrames; frame++){
        // background
        ctx.fillStyle = '#08121b'; ctx.fillRect(0,0,W,H);

        // determine how many images are "active" at this frame
        const activeCount = Math.min(n, Math.floor(frame / perImageFrame) + 1);

        // draw active images with a small animation from center to their cell
        for(let i=0;i<activeCount;i++){
          const t0 = i*perImageFrame; // frame when this image started appearing
          const local = Math.max(0, Math.min(1, (frame - t0) / perImageFrame));
          // ease out cubic
          const ease = 1 - Math.pow(1-local,3);

          const target = targets[i];
          const centerX = (W/2 - (target.w/2));
          const centerY = (H/2 - (target.h/2));

          const curX = centerX + (target.x - centerX) * ease;
          const curY = centerY + (target.y - centerY) * ease;
          const curW = target.w * ease;
          const curH = target.h * ease;

          // draw image fitted inside curW x curH
          const img = images[i];
          // compute aspect-fit
          const ar = img.width / img.height;
          let dw = curW, dh = curH;
          if(dw / dh > ar){ dw = dh * ar; } else { dh = dw / ar; }
          const dx = curX + (curW - dw)/2; const dy = curY + (curH - dh)/2;

          // subtle border
          ctx.save();
          ctx.beginPath();
          roundRect(ctx, curX, curY, curW, curH, 6);
          ctx.clip();
          ctx.drawImage(img, dx, dy, dw, dh);
          ctx.restore();

          // optional small shadow
          ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.lineWidth = 2;
          ctx.strokeRect(curX+1, curY+1, curW-2, curH-2);
        }

        // small vignette
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(0,0,W,H);

        // frame delay
        await wait(1000 / fps);
      }

      log('Animação concluída — ' + totalFrames + ' frames gerados.');
    }

    function roundRect(ctx,x,y,w,h,r){ if(r===undefined) r=6; ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
    function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // FFmpeg conversion using ffmpeg.wasm
    async function convertToMP4(webmBlob){
      // lazy load ffmpeg
      if(!window.createFFmpeg){
        log('Baixando biblioteca ffmpeg (um grande arquivo). Aguarde...');
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js';
        document.head.appendChild(s);
        await new Promise((res,rej)=>{ s.onload = res; s.onerror = ()=>rej(new Error('Falha ao baixar ffmpeg.wasm')); });
      }
      const {createFFmpeg, fetchFile} = window.FFmpeg;
      const ffmpeg = createFFmpeg({log:true});
      log('Inicializando ffmpeg...');
      await ffmpeg.load();
      log('Escrevendo arquivo para FS virtual...');
      const data = await fetchFile(webmBlob);
      ffmpeg.FS('writeFile', 'in.webm', data);
      log('Executando conversão para MP4 (isso pode demorar bastante)...');
      // convert with libx264
      await ffmpeg.run('-i','in.webm','-c:v','libx264','-crf','23','-preset','veryfast','out.mp4');
      log('Leitura do MP4...');
      const mp4Data = ffmpeg.FS('readFile','out.mp4');
      const mp4Blob = new Blob([mp4Data.buffer], {type:'video/mp4'});
      log('MP4 gerado — tamanho: ' + Math.round(mp4Blob.size/1024/1024) + ' MB');
      const a = document.createElement('a'); a.href = URL.createObjectURL(mp4Blob); a.download = 'mosaico.mp4'; a.click();
    }

  </script>
</body>
</html>
