<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vídeo Zoom-Out Mosaico 4K</title>
<style>
  :root{--bg:#0f1724;--accent:#06b6d4;--muted:#94a3b8;color-scheme:dark}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071025,#0f1724);color:#e6eef6;font-family:Inter,system-ui,Arial;display:flex;align-items:center;justify-content:center;padding:20px}
  .card{background:rgba(255,255,255,0.05);padding:20px;border-radius:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);max-width:900px;width:100%}
  h1{font-size:20px;margin:0 0 10px 0;text-align:center}
  p{font-size:14px;color:var(--muted);text-align:center;margin-bottom:20px}
  input[type=file]{display:none}
  .btn{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;padding:10px 18px;border-radius:10px;color:#021124;cursor:pointer;font-weight:600;display:inline-block;margin-bottom:10px}
  #canvas{display:block;margin:10px auto;background:#000;border-radius:10px;max-width:100%}
  #log{font-family:monospace;font-size:13px;color:var(--muted);height:120px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px}
  .small{text-align:center;font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<div class="card">
  <h1>Gerador de Vídeo Zoom-Out 4K</h1>
  <p>Envie suas fotos. O vídeo começa com a primeira foto em tela cheia e vai revelando as outras em mosaico durante o zoom-out.</p>
  <div style="text-align:center">
    <label for="files" class="btn">Selecionar Fotos</label>
    <input id="files" type="file" accept="image/*" multiple>
    <button id="generate" class="btn">Gerar Vídeo (WebM)</button>
  </div>
  <canvas id="canvas" width="3840" height="2160"></canvas>
  <div id="log"></div>
  <p class="small">O vídeo será exportado em WebM, que pode ser convertido para MP4 localmente com FFmpeg.</p>
</div>
<script>
const filesInput = document.getElementById('files');
const generateBtn = document.getElementById('generate');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log');
let images = [];

function log(msg){ logEl.textContent += msg + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function clearLog(){ logEl.textContent = ''; }

filesInput.addEventListener('change', async (ev)=>{
  clearLog();
  const list = Array.from(ev.target.files).filter(f=>f.type.startsWith('image/'));
  log('Carregando ' + list.length + ' imagens...');
  images = [];
  for(const f of list){
    const url = URL.createObjectURL(f);
    const img = await loadImage(url);
    images.push(img);
  }
  log('Todas as imagens carregadas ('+images.length+')');
});

function loadImage(src){
  return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; i.crossOrigin='anonymous'; });
}

// Função que desenha a imagem cobrindo o tile (cover)
function drawCover(ctx, img, x, y, w, h){
  const arImg = img.width / img.height;
  const arTile = w / h;
  let dw = w, dh = h, sx=0, sy=0, sw=img.width, sh=img.height;
  if(arImg > arTile){ // imagem mais larga -> cortar sides
    dh = h; dw = Math.round(h * arImg);
    sx = Math.floor((dw - w)/2 / dw * img.width);
    sw = Math.floor(img.width - sx*2);
    sh = img.height;
    ctx.drawImage(img, sx, 0, sw, sh, x, y, w, h);
  } else { // imagem mais alta -> cortar top/bottom
    dw = w; dh = Math.round(w / arImg);
    sy = Math.floor((dh - h)/2 / dh * img.height);
    sh = Math.floor(img.height - sy*2);
    sw = img.width;
    ctx.drawImage(img, 0, sy, sw, sh, x, y, w, h);
  }
}

generateBtn.addEventListener('click', ()=>{
  if(images.length===0){ alert('Selecione as fotos primeiro.'); return; }
  generateBtn.disabled = true;
  clearLog();
  log('Gerando vídeo zoom-out com ' + images.length + ' fotos...');
  generateVideo();
});

async function generateVideo(){
  const width = 3840, height = 2160, fps = 30, duration = 20;
  const totalFrames = duration * fps;

  const cols = Math.ceil(Math.sqrt(images.length));
  const rows = Math.ceil(images.length / cols);

  // limita o bigCanvas para não explodir a memória
  const MAX_BIG_DIM = 16384; // limite seguro na maioria dos navegadores
  let tileSize = Math.floor(Math.min(1024, Math.floor(MAX_BIG_DIM / Math.max(cols, rows))));
  tileSize = Math.max(tileSize, 64); // mínimo

  const bigW = cols * tileSize;
  const bigH = rows * tileSize;

  const bigCanvas = document.createElement('canvas');
  bigCanvas.width = bigW;
  bigCanvas.height = bigH;
  const bctx = bigCanvas.getContext('2d');
  bctx.fillStyle = '#000'; bctx.fillRect(0,0,bigW,bigH);

  // order: primeira imagem é central
  const centralImage = images[0];
  const others = images.slice(1);
  const ordered = [centralImage, ...others];

  const centerCol = Math.floor(cols/2);
  const centerRow = Math.floor(rows/2);

  ordered.forEach((img,i)=>{
    let c,r;
    if(i===0){ c=centerCol; r=centerRow; }
    else{ const idx=i-1; c = idx % cols; r = Math.floor(idx/cols); if(c===centerCol && r===centerRow){ c++; } }
    drawCover(bctx, img, c*tileSize, r*tileSize, tileSize, tileSize);
  });

  log('Mosaico preparado: ' + cols + 'x' + rows + ' tiles, tileSize=' + tileSize + ', bigCanvas=' + bigW + 'x' + bigH);

  // centro da foto central
  const cx = centerCol*tileSize + tileSize/2;
  const cy = centerRow*tileSize + tileSize/2;

  const stream = canvas.captureStream(fps);
  const recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9', videoBitsPerSecond: 80000000});
  const chunks = [];
  recorder.ondataavailable = e=>{ if(e.data.size>0) chunks.push(e.data); };
  recorder.onstop = ()=>{
    const blob = new Blob(chunks,{type:'video/webm'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='zoomout_4k.webm'; a.click();
    log('Vídeo WebM pronto!');
    generateBtn.disabled = false;
  };
  recorder.start();

  let frame = 0;
  function drawFrame(){
    if(frame >= totalFrames){ recorder.stop(); return; }
    const t = frame / (totalFrames - 1);

    // interpolar view width entre tileSize (começa mostrando a tile) e bigW (mosaico completo)
    let viewW = tileSize + (bigW - tileSize) * t;
    let viewH = viewW * (bigH / bigW); // mantém proporção do bigCanvas

    // proteger caso viewH > bigH
    if(viewH > bigH){ viewH = bigH; viewW = viewH * (bigW / bigH); }

    let sx = cx - viewW/2;
    let sy = cy - viewH/2;
    // clamp
    if(sx < 0) sx = 0; if(sy < 0) sy = 0;
    if(sx + viewW > bigW) sx = bigW - viewW;
    if(sy + viewH > bigH) sy = bigH - viewH;

    // desenha o pedaço do mosaico escalado para a tela
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,width,height);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(bigCanvas, sx, sy, viewW, viewH, 0, 0, width, height);

    frame++;
    requestAnimationFrame(drawFrame);
  }
  requestAnimationFrame(drawFrame);
}
</script>
</body>
</html>
